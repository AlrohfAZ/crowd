// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Crowdfunding {
    struct Campaign {
        address payable creator;
        string title;
        string description;
        string imageURL;
        uint256 targetAmount;
        uint256 minimumContribution;
        uint256 deadline;
        uint256 amountRaised;
        uint256 contributorsCount;
        uint256 totalContributions;
        bool hasTransfered;
    }

    uint256 public nextCampaignId; // Starts at 0 by default
    mapping(uint256 => Campaign) public campaigns;
    uint256[] public campaignIds;

    event CampaignCreated(
        uint256 campaignId,
        address creator,
        string title,
        uint256 targetAmount,
        uint256 deadline
    );

    /**
     * @dev Creates a new crowdfunding campaign.
     * @param _title The title of the campaign.
     * @param _description A detailed description of the campaign.
     * @param _imageURL URL for a campaign image.
     * @param _targetAmount The total amount of funds the campaign aims to raise (in Wei).
     * @param _minimumContribution The minimum amount a single contributor can send (in Wei).
     * @param _deadline Unix timestamp representing the campaign's end date.
     * @return The ID of the newly created campaign.
     */

    function createCampaign(
        string memory _title,
        string memory _description,
        string memory _imageURL,
        uint256 _targetAmount,
        uint256 _minimumContribution,
        uint256 _deadline
    ) public returns (uint256) {
        // Input validation
        require(_deadline > block.timestamp, "Deadline must be in the future");
        require(_targetAmount > 0, "Target amount must be greater than zero");
        require(
            _minimumContribution > 0,
            "Minimum contribution must be greater than zero"
        );
        require(
            _minimumContribution <= _targetAmount,
            "Minimum contribution cannot exceed target amount"
        );
        require(
            _targetAmount >= _minimumContribution * 10,
            "Target amount must be at least 10 times the minimum contribution"
        );

        // Get the current campaign ID for the new campaign
        uint256 currentCampaignId = nextCampaignId;

        // Increment the nextCampaignId for the subsequent campaign
        nextCampaignId++;

        // Create a new Campaign struct
        Campaign storage newCampaign = campaigns[currentCampaignId]; // This creates a storage reference

        newCampaign.creator = payable(msg.sender); // The creator is the one calling this function
        newCampaign.title = _title;
        newCampaign.description = _description;
        newCampaign.imageURL = _imageURL;
        newCampaign.targetAmount = _targetAmount;
        newCampaign.minimumContribution = _minimumContribution;
        newCampaign.deadline = _deadline;
        newCampaign.amountRaised = 0; // Initially, no funds are raised
        newCampaign.contributorsCount = 0; // Initially, no contributors
        newCampaign.totalContributions = 0;

        // Add the new campaign's ID to the array of all campaign IDs
        campaignIds.push(currentCampaignId);

        // Emit an event to notify off-chain applications
        emit CampaignCreated(
            currentCampaignId,
            msg.sender,
            _title,
            _targetAmount,
            _deadline
        );

        return currentCampaignId;
    }

    // Function to get details of a specific campaign (generated by 'public' keyword on mapping)
    // getCampaignDetails function is more gas efficient as it gets details for a specific campaignId rather than all capmaigns
    function getCampaignDetails(
        uint256 _campaignId
    )
        public
        view
        returns (
            address creator,
            string memory title,
            uint256 targetAmount,
            uint256 deadline,
            uint256 amountRaised
        )
    {
        require(_campaignId < nextCampaignId, "Campaign ID does not exist");
        campaignIds[_campaignId];
        Campaign storage campaign = campaigns[_campaignId];
        return (
            campaign.creator,
            campaign.title,
            campaign.targetAmount,
            campaign.deadline,
            campaign.amountRaised
        );
    }

    // Function to get the number of existing campaigns
    function getCampaignsCount() public view returns (uint256) {
        return campaignIds.length;
    }

    // Function to get all campaign IDs (useful for frontends to fetch details of all campaigns)
    function getAllCampaignIds() public view returns (uint256[] memory) {
        return campaignIds;
    }
    // Function to get all active campaigns and their details
    function getOngoingCampaignsSummary()
        public
        view
        returns (
            uint256[] memory campaignIdsArray,
            string[] memory titles,
            address[] memory creators,
            uint256[] memory targetAmounts,
            uint256[] memory deadlines
        )
    {
        uint256 activeCount = 0;
        for (uint256 i = 0; i < campaignIds.length; i++) {
            if (campaigns[campaignIds[i]].deadline > block.timestamp) {
                activeCount++;
            }
        }
        uint256[] memory ids = new uint256[](activeCount);
        string[] memory _titles = new string[](activeCount);
        address[] memory _creators = new address[](activeCount);
        uint256[] memory _targets = new uint256[](activeCount);
        uint256[] memory _deadlines = new uint256[](activeCount);
        uint256 currentIndex = 0;
        for (uint256 i = 0; i < campaignIds.length; i++) {
            Campaign storage campaign = campaigns[campaignIds[i]];
            if (campaign.deadline > block.timestamp) {
                ids[currentIndex] = campaignIds[i];
                _titles[currentIndex] = campaign.title;
                _creators[currentIndex] = campaign.creator;
                _targets[currentIndex] = campaign.targetAmount;
                _deadlines[currentIndex] = campaign.deadline;
                currentIndex++;
            }
        }
        return (ids, _titles, _creators, _targets, _deadlines);
    }

    // Function takes in a campaignID and receives value(Contributions) from users
    function contirbution(
        uint256 _campaignIds
    ) public payable returns (uint256 totalContributions) {
        uint256 amount = msg.value;
        Campaign storage campaign = campaigns[_campaignIds];
        campaignIds[_campaignIds];
        require(_campaignIds < nextCampaignId, "Campaign ID does not exist");
        campaigns[_campaignIds].amountRaised += msg.value;
        if (campaigns[_campaignIds].totalContributions > 0) {
            totalContributions += amount;
        }
        return campaign.totalContributions;
    }
    // CREATE A WITHDRAW FUNCTION
    function withdrawFunds(
        uint256 _campaignId
    ) public returns (uint256 amountRaised) {
        campaignIds[_campaignId];
        Campaign storage campaign = campaigns[_campaignId];
        uint256 amountToWithdraw = campaign.amountRaised;
        require(
            msg.sender == campaign.creator,
            "NO BE YOU CREATE THIS CAMPAIGN, OLE!"
        );
        require(
            campaign.deadline <= block.timestamp,
            "You have not met the deadline of your campaign"
        );
        require(campaign.amountRaised > 0, "Your campaign has no funds");
        campaign.amountRaised = 0;
        (bool success, ) = campaign.creator.call{value: amountToWithdraw}("");
        require(success, "Transfer failed");
        return campaign.amountRaised;
    }
}
